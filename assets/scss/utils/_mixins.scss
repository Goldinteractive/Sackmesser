@mixin respond-to($breakpoint) {
  @if map-has-key($breakpoints, $breakpoint) {
    @media #{map-get($breakpoints, $breakpoint)} {
      @content;
    }
  } @else {
    @error 'No value found for `#{$breakpoint}`. ' + 'Please make sure it is defined in `$breakpoints` map.';
  }
}

/**
 * Simpler shortcut to create easily break points
 */

@mixin breakpoint-down($width) {
  @media only screen and (max-width: $width) {
    @content;
  }
}

@mixin breakpoint-up($width) {
  @media only screen and (min-width: $width) {
    @content;
  }
}

@mixin breakpoint-between($min, $max) {
    @media only screen and (min-width: $min) and (max-width: $max) {
        @content;
    }
}

/**
 * For hacks. Use wisely.
 */

@mixin ie9() {
    @media screen and (min-width:0\0) {
        @content;
    }
}

@mixin firefox() {
    @-moz-document url-prefix() {
        @content;
    }
}

/**
 * Object mixin to make polyfill working.
 */
@mixin object($fit: cover, $position: center center) {
    width: 100%;
    height: 100%;
    object-fit: $fit;
    object-position: $position;
}

/**
 * Easy functions to create easily pure css arrows anywhere
 */

@mixin arrow-up($size: 10px, $color: #000) {
  width: 0;
  height: 0;
  border-left: $size solid transparent;
  border-right: $size solid transparent;
  border-bottom: $size solid $color;
}

@mixin arrow-down($size: 10px, $color: #000) {
  width: 0;
  height: 0;
  border-left: $size solid transparent;
  border-right: $size solid transparent;
  border-top: $size solid $color;
}

@mixin arrow-right($size: 10px, $color: #000) {
  width: 0;
  height: 0;
  border-top: $size solid transparent;
  border-bottom: $size solid transparent;
  border-left: $size solid $color;
}

@mixin arrow-left($size: 10px, $color: #000) {
  width: 0;
  height: 0;
  border-top: $size solid transparent;
  border-bottom: $size solid transparent;
  border-right: $size solid $color;
}

// Sizing shortcuts
// -------------------------
@mixin size($width, $height) {
  width: $width;
  height: $height;
}

@mixin square($size) {
  @include size($size, $size);
}

// organize the stacking order using the $layers variable
@mixin z-index($level: 'content') {
  z-index: map-get($layers, $level);
}

/**
 * Mixin to print any kind of font contained in the $font-types map
 * @param   { String } $id:        'font-type-1'
 * @param   { Boolean } $use-media: true
 */
@mixin font-type($id: $default-font-type, $use-media: true, $use-font-config: true) {

  @if map-has-key($font-types, $id) == false {
    @error 'No font-type `#{$id}` found. ' + 'Please make sure it is defined in `$font-types` map.';
  }

  $fontType: map-get($font-types, $id);
  // loop all the properties found in this font type
  @each $prop, $val in $fontType {
    // check if this font has special media values
    // normally they should be a map as well
    @if ($prop == 'media' and $use-media) {
      // loop all the media types
      @each $media-type, $media-values in $val {
        // create the responsive rules
        @include respond-to($media-type) {
          // print all the media rules
          @each $prop, $val in $media-values {
            #{$prop}: #{$val};
          }
        }
      }
    } @elseif ($prop == 'config' and $use-font-config) {
        $font: map_get($val, 'font');
        $font-weight: map_get($val, 'weight');
        @include font-family($font);
        @include font-weight($font-weight, $font);
    } @else {
      @if ($prop != 'media') {
        #{$prop}: #{$val};
      }
    }
  }
}

// Return font-weight
@mixin font-weight($weight: $default-font-weight, $font: $default-font) {
    $font-config: map_get($fonts, $font);
    $font-weights: map_get($font-config, 'weights');
    $font-weight: map_get($font-weights, $weight);
    font-weight: $font-weight;
}

// Return font-family
@mixin font-family($font: $default-font) {
    $font-config: map_get($fonts, $font);
    $font-family: map_get($font-config, 'family');
    font-family: $font-family;
}



@mixin vspace($type, $property: $vspaces-attribute-default) {
  $config: map-get($vspaces, $type);

  @if (map-has-key($vspaces, $type) == false) {
    @error 'No value found for `#{$type}`. ' + 'Please make sure it is defined in `$vspaces` map.';
  }

  $default: map-get($config, 'default');
  $breakpoints: map-get($config, 'breakpoints');

  #{$property}: $default;

  @each $breakpoint, $vspace in $breakpoints {
    @if ($vspace) {
      @include respond-to($breakpoint) {
        #{$property}: $vspace;
      }
    }
  }
}



/// https://css-tricks.com/snippets/sass/viewport-sized-typography-minimum-maximum-sizes/
/// Viewport sized typography with minimum and maximum values
///
/// @author Eduardo Boucas (@eduardoboucas)
///
/// @param {Number}   $responsive  - Viewport-based size
/// @param {Number}   $min         - Minimum font size (px)
/// @param {Number}   $max         - Maximum font size (px)
///                                  (optional)
/// @param {Number}   $fallback    - Fallback for viewport-
///                                  based units (optional)
///
/// @example scss - 5vw font size (with 50px fallback),
///                 minumum of 35px and maximum of 150px
///  @include responsive-font(5vw, 35px, 150px, 50px);
///
@mixin responsive-font($responsive, $min, $max: false, $fallback: false) {
  $responsive-unitless: $responsive / ($responsive - $responsive + 1);
  $dimension: if(unit($responsive) == 'vh', 'height', 'width');
  $min-breakpoint: $min / $responsive-unitless * 100;

  @media (max-#{$dimension}: #{$min-breakpoint}) {
    font-size: $min;
  }

  @if $max {
    $max-breakpoint: $max / $responsive-unitless * 100;

    @media (min-#{$dimension}: #{$max-breakpoint}) {
      font-size: $max;
    }
  }

  @if $fallback {
    font-size: $fallback;
  }

  font-size: $responsive;
}

